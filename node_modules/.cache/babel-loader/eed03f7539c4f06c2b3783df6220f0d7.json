{"ast":null,"code":"/*!\r\n * body-parser\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n'use strict';\n/**\r\n * Module dependencies.\r\n */\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar bytes = require('bytes');\n\nvar contentType = require('content-type');\n\nvar debug = require('debug')('body-parser:text');\n\nvar read = require('../read');\n\nvar typeis = require('type-is');\n/**\r\n * Module exports.\r\n */\n\n\nmodule.exports = text;\n/**\r\n * Create a middleware to parse text bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @api public\r\n */\n\nfunction text(options) {\n  var opts = options || {};\n  var defaultCharset = opts.defaultCharset || 'utf-8';\n  var inflate = opts.inflate !== false;\n  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;\n  var type = opts.type || 'text/plain';\n  var verify = opts.verify || false;\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  } // create the appropriate type checking function\n\n\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n\n  function parse(buf) {\n    return buf;\n  }\n\n  return function textParser(req, res, next) {\n    if (req._body) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n\n    req.body = req.body || {}; // skip requests without bodies\n\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n\n    debug('content-type %j', req.headers['content-type']); // determine if request should be parsed\n\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    } // get charset\n\n\n    var charset = getCharset(req) || defaultCharset; // read\n\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\n/**\r\n * Get the charset of a request.\r\n *\r\n * @param {object} req\r\n * @api private\r\n */\n\n\nfunction getCharset(req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch (e) {\n    return undefined;\n  }\n}\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n */\n\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}","map":{"version":3,"names":["bytes","require","contentType","debug","read","typeis","module","exports","text","options","opts","defaultCharset","inflate","limit","parse","type","verify","TypeError","shouldParse","typeChecker","buf","textParser","req","res","next","_body","body","hasBody","headers","charset","getCharset","encoding","parameters","toLowerCase","e","undefined","checkType","Boolean"],"sources":["E:/adminDeal/node_modules/body-parser/lib/types/text.js"],"sourcesContent":["/*!\r\n * body-parser\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict'\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar bytes = require('bytes')\r\nvar contentType = require('content-type')\r\nvar debug = require('debug')('body-parser:text')\r\nvar read = require('../read')\r\nvar typeis = require('type-is')\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = text\r\n\r\n/**\r\n * Create a middleware to parse text bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @api public\r\n */\r\n\r\nfunction text (options) {\r\n  var opts = options || {}\r\n\r\n  var defaultCharset = opts.defaultCharset || 'utf-8'\r\n  var inflate = opts.inflate !== false\r\n  var limit = typeof opts.limit !== 'number'\r\n    ? bytes.parse(opts.limit || '100kb')\r\n    : opts.limit\r\n  var type = opts.type || 'text/plain'\r\n  var verify = opts.verify || false\r\n\r\n  if (verify !== false && typeof verify !== 'function') {\r\n    throw new TypeError('option verify must be function')\r\n  }\r\n\r\n  // create the appropriate type checking function\r\n  var shouldParse = typeof type !== 'function'\r\n    ? typeChecker(type)\r\n    : type\r\n\r\n  function parse (buf) {\r\n    return buf\r\n  }\r\n\r\n  return function textParser (req, res, next) {\r\n    if (req._body) {\r\n      debug('body already parsed')\r\n      next()\r\n      return\r\n    }\r\n\r\n    req.body = req.body || {}\r\n\r\n    // skip requests without bodies\r\n    if (!typeis.hasBody(req)) {\r\n      debug('skip empty body')\r\n      next()\r\n      return\r\n    }\r\n\r\n    debug('content-type %j', req.headers['content-type'])\r\n\r\n    // determine if request should be parsed\r\n    if (!shouldParse(req)) {\r\n      debug('skip parsing')\r\n      next()\r\n      return\r\n    }\r\n\r\n    // get charset\r\n    var charset = getCharset(req) || defaultCharset\r\n\r\n    // read\r\n    read(req, res, next, parse, debug, {\r\n      encoding: charset,\r\n      inflate: inflate,\r\n      limit: limit,\r\n      verify: verify\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Get the charset of a request.\r\n *\r\n * @param {object} req\r\n * @api private\r\n */\r\n\r\nfunction getCharset (req) {\r\n  try {\r\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\r\n  } catch (e) {\r\n    return undefined\r\n  }\r\n}\r\n\r\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n */\r\n\r\nfunction typeChecker (type) {\r\n  return function checkType (req) {\r\n    return Boolean(typeis(req, type))\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}