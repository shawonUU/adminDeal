{"ast":null,"code":"/*!\r\n * raw-body\r\n * Copyright(c) 2013-2014 Jonathan Ong\r\n * Copyright(c) 2014-2022 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n'use strict';\n/**\r\n * Module dependencies.\r\n * @private\r\n */\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar asyncHooks = tryRequireAsyncHooks();\n\nvar bytes = require('bytes');\n\nvar createError = require('http-errors');\n\nvar iconv = require('iconv-lite');\n\nvar unpipe = require('unpipe');\n/**\r\n * Module exports.\r\n * @public\r\n */\n\n\nmodule.exports = getRawBody;\n/**\r\n * Module variables.\r\n * @private\r\n */\n\nvar ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;\n/**\r\n * Get the decoder for a given encoding.\r\n *\r\n * @param {string} encoding\r\n * @private\r\n */\n\nfunction getDecoder(encoding) {\n  if (!encoding) return null;\n\n  try {\n    return iconv.getDecoder(encoding);\n  } catch (e) {\n    // error getting decoder\n    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e; // the encoding was not found\n\n    throw createError(415, 'specified encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    });\n  }\n}\n/**\r\n * Get the raw body of a stream (typically HTTP).\r\n *\r\n * @param {object} stream\r\n * @param {object|string|function} [options]\r\n * @param {function} [callback]\r\n * @public\r\n */\n\n\nfunction getRawBody(stream, options, callback) {\n  var done = callback;\n  var opts = options || {};\n\n  if (options === true || typeof options === 'string') {\n    // short cut for encoding\n    opts = {\n      encoding: options\n    };\n  }\n\n  if (typeof options === 'function') {\n    done = options;\n    opts = {};\n  } // validate callback is a function, if provided\n\n\n  if (done !== undefined && typeof done !== 'function') {\n    throw new TypeError('argument callback must be a function');\n  } // require the callback without promises\n\n\n  if (!done && !global.Promise) {\n    throw new TypeError('argument callback is required');\n  } // get encoding\n\n\n  var encoding = opts.encoding !== true ? opts.encoding : 'utf-8'; // convert the limit to an integer\n\n  var limit = bytes.parse(opts.limit); // convert the expected length to an integer\n\n  var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;\n\n  if (done) {\n    // classic callback style\n    return readStream(stream, encoding, length, limit, wrap(done));\n  }\n\n  return new Promise(function executor(resolve, reject) {\n    readStream(stream, encoding, length, limit, function onRead(err, buf) {\n      if (err) return reject(err);\n      resolve(buf);\n    });\n  });\n}\n/**\r\n * Halt a stream.\r\n *\r\n * @param {Object} stream\r\n * @private\r\n */\n\n\nfunction halt(stream) {\n  // unpipe everything from the stream\n  unpipe(stream); // pause stream\n\n  if (typeof stream.pause === 'function') {\n    stream.pause();\n  }\n}\n/**\r\n * Read the data from the stream.\r\n *\r\n * @param {object} stream\r\n * @param {string} encoding\r\n * @param {number} length\r\n * @param {number} limit\r\n * @param {function} callback\r\n * @public\r\n */\n\n\nfunction readStream(stream, encoding, length, limit, callback) {\n  var complete = false;\n  var sync = true; // check the length and limit options.\n  // note: we intentionally leave the stream paused,\n  // so users should handle the stream themselves.\n\n  if (limit !== null && length !== null && length > limit) {\n    return done(createError(413, 'request entity too large', {\n      expected: length,\n      length: length,\n      limit: limit,\n      type: 'entity.too.large'\n    }));\n  } // streams1: assert request encoding is buffer.\n  // streams2+: assert the stream encoding is buffer.\n  //   stream._decoder: streams1\n  //   state.encoding: streams2\n  //   state.decoder: streams2, specifically < 0.10.6\n\n\n  var state = stream._readableState;\n\n  if (stream._decoder || state && (state.encoding || state.decoder)) {\n    // developer error\n    return done(createError(500, 'stream encoding should not be set', {\n      type: 'stream.encoding.set'\n    }));\n  }\n\n  if (typeof stream.readable !== 'undefined' && !stream.readable) {\n    return done(createError(500, 'stream is not readable', {\n      type: 'stream.not.readable'\n    }));\n  }\n\n  var received = 0;\n  var decoder;\n\n  try {\n    decoder = getDecoder(encoding);\n  } catch (err) {\n    return done(err);\n  }\n\n  var buffer = decoder ? '' : []; // attach listeners\n\n  stream.on('aborted', onAborted);\n  stream.on('close', cleanup);\n  stream.on('data', onData);\n  stream.on('end', onEnd);\n  stream.on('error', onEnd); // mark sync section complete\n\n  sync = false;\n\n  function done() {\n    var args = new Array(arguments.length); // copy arguments\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    } // mark complete\n\n\n    complete = true;\n\n    if (sync) {\n      process.nextTick(invokeCallback);\n    } else {\n      invokeCallback();\n    }\n\n    function invokeCallback() {\n      cleanup();\n\n      if (args[0]) {\n        // halt the stream on error\n        halt(stream);\n      }\n\n      callback.apply(null, args);\n    }\n  }\n\n  function onAborted() {\n    if (complete) return;\n    done(createError(400, 'request aborted', {\n      code: 'ECONNABORTED',\n      expected: length,\n      length: length,\n      received: received,\n      type: 'request.aborted'\n    }));\n  }\n\n  function onData(chunk) {\n    if (complete) return;\n    received += chunk.length;\n\n    if (limit !== null && received > limit) {\n      done(createError(413, 'request entity too large', {\n        limit: limit,\n        received: received,\n        type: 'entity.too.large'\n      }));\n    } else if (decoder) {\n      buffer += decoder.write(chunk);\n    } else {\n      buffer.push(chunk);\n    }\n  }\n\n  function onEnd(err) {\n    if (complete) return;\n    if (err) return done(err);\n\n    if (length !== null && received !== length) {\n      done(createError(400, 'request size did not match content length', {\n        expected: length,\n        length: length,\n        received: received,\n        type: 'request.size.invalid'\n      }));\n    } else {\n      var string = decoder ? buffer + (decoder.end() || '') : Buffer.concat(buffer);\n      done(null, string);\n    }\n  }\n\n  function cleanup() {\n    buffer = null;\n    stream.removeListener('aborted', onAborted);\n    stream.removeListener('data', onData);\n    stream.removeListener('end', onEnd);\n    stream.removeListener('error', onEnd);\n    stream.removeListener('close', cleanup);\n  }\n}\n/**\r\n * Try to require async_hooks\r\n * @private\r\n */\n\n\nfunction tryRequireAsyncHooks() {\n  try {\n    return require('async_hooks');\n  } catch (e) {\n    return {};\n  }\n}\n/**\r\n * Wrap function with async resource, if possible.\r\n * AsyncResource.bind static method backported.\r\n * @private\r\n */\n\n\nfunction wrap(fn) {\n  var res; // create anonymous resource\n\n  if (asyncHooks.AsyncResource) {\n    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');\n  } // incompatible node.js\n\n\n  if (!res || !res.runInAsyncScope) {\n    return fn;\n  } // return bound function\n\n\n  return res.runInAsyncScope.bind(res, fn, null);\n}","map":{"version":3,"names":["asyncHooks","tryRequireAsyncHooks","bytes","require","createError","iconv","unpipe","module","exports","getRawBody","ICONV_ENCODING_MESSAGE_REGEXP","getDecoder","encoding","e","test","message","type","stream","options","callback","done","opts","undefined","TypeError","global","Promise","limit","parse","length","isNaN","parseInt","readStream","wrap","executor","resolve","reject","onRead","err","buf","halt","pause","complete","sync","expected","state","_readableState","_decoder","decoder","readable","received","buffer","on","onAborted","cleanup","onData","onEnd","args","Array","arguments","i","process","nextTick","invokeCallback","apply","code","chunk","write","push","string","end","Buffer","concat","removeListener","fn","res","AsyncResource","name","runInAsyncScope","bind"],"sources":["E:/adminDeal/node_modules/raw-body/index.js"],"sourcesContent":["/*!\r\n * raw-body\r\n * Copyright(c) 2013-2014 Jonathan Ong\r\n * Copyright(c) 2014-2022 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict'\r\n\r\n/**\r\n * Module dependencies.\r\n * @private\r\n */\r\n\r\nvar asyncHooks = tryRequireAsyncHooks()\r\nvar bytes = require('bytes')\r\nvar createError = require('http-errors')\r\nvar iconv = require('iconv-lite')\r\nvar unpipe = require('unpipe')\r\n\r\n/**\r\n * Module exports.\r\n * @public\r\n */\r\n\r\nmodule.exports = getRawBody\r\n\r\n/**\r\n * Module variables.\r\n * @private\r\n */\r\n\r\nvar ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /\r\n\r\n/**\r\n * Get the decoder for a given encoding.\r\n *\r\n * @param {string} encoding\r\n * @private\r\n */\r\n\r\nfunction getDecoder (encoding) {\r\n  if (!encoding) return null\r\n\r\n  try {\r\n    return iconv.getDecoder(encoding)\r\n  } catch (e) {\r\n    // error getting decoder\r\n    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e\r\n\r\n    // the encoding was not found\r\n    throw createError(415, 'specified encoding unsupported', {\r\n      encoding: encoding,\r\n      type: 'encoding.unsupported'\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Get the raw body of a stream (typically HTTP).\r\n *\r\n * @param {object} stream\r\n * @param {object|string|function} [options]\r\n * @param {function} [callback]\r\n * @public\r\n */\r\n\r\nfunction getRawBody (stream, options, callback) {\r\n  var done = callback\r\n  var opts = options || {}\r\n\r\n  if (options === true || typeof options === 'string') {\r\n    // short cut for encoding\r\n    opts = {\r\n      encoding: options\r\n    }\r\n  }\r\n\r\n  if (typeof options === 'function') {\r\n    done = options\r\n    opts = {}\r\n  }\r\n\r\n  // validate callback is a function, if provided\r\n  if (done !== undefined && typeof done !== 'function') {\r\n    throw new TypeError('argument callback must be a function')\r\n  }\r\n\r\n  // require the callback without promises\r\n  if (!done && !global.Promise) {\r\n    throw new TypeError('argument callback is required')\r\n  }\r\n\r\n  // get encoding\r\n  var encoding = opts.encoding !== true\r\n    ? opts.encoding\r\n    : 'utf-8'\r\n\r\n  // convert the limit to an integer\r\n  var limit = bytes.parse(opts.limit)\r\n\r\n  // convert the expected length to an integer\r\n  var length = opts.length != null && !isNaN(opts.length)\r\n    ? parseInt(opts.length, 10)\r\n    : null\r\n\r\n  if (done) {\r\n    // classic callback style\r\n    return readStream(stream, encoding, length, limit, wrap(done))\r\n  }\r\n\r\n  return new Promise(function executor (resolve, reject) {\r\n    readStream(stream, encoding, length, limit, function onRead (err, buf) {\r\n      if (err) return reject(err)\r\n      resolve(buf)\r\n    })\r\n  })\r\n}\r\n\r\n/**\r\n * Halt a stream.\r\n *\r\n * @param {Object} stream\r\n * @private\r\n */\r\n\r\nfunction halt (stream) {\r\n  // unpipe everything from the stream\r\n  unpipe(stream)\r\n\r\n  // pause stream\r\n  if (typeof stream.pause === 'function') {\r\n    stream.pause()\r\n  }\r\n}\r\n\r\n/**\r\n * Read the data from the stream.\r\n *\r\n * @param {object} stream\r\n * @param {string} encoding\r\n * @param {number} length\r\n * @param {number} limit\r\n * @param {function} callback\r\n * @public\r\n */\r\n\r\nfunction readStream (stream, encoding, length, limit, callback) {\r\n  var complete = false\r\n  var sync = true\r\n\r\n  // check the length and limit options.\r\n  // note: we intentionally leave the stream paused,\r\n  // so users should handle the stream themselves.\r\n  if (limit !== null && length !== null && length > limit) {\r\n    return done(createError(413, 'request entity too large', {\r\n      expected: length,\r\n      length: length,\r\n      limit: limit,\r\n      type: 'entity.too.large'\r\n    }))\r\n  }\r\n\r\n  // streams1: assert request encoding is buffer.\r\n  // streams2+: assert the stream encoding is buffer.\r\n  //   stream._decoder: streams1\r\n  //   state.encoding: streams2\r\n  //   state.decoder: streams2, specifically < 0.10.6\r\n  var state = stream._readableState\r\n  if (stream._decoder || (state && (state.encoding || state.decoder))) {\r\n    // developer error\r\n    return done(createError(500, 'stream encoding should not be set', {\r\n      type: 'stream.encoding.set'\r\n    }))\r\n  }\r\n\r\n  if (typeof stream.readable !== 'undefined' && !stream.readable) {\r\n    return done(createError(500, 'stream is not readable', {\r\n      type: 'stream.not.readable'\r\n    }))\r\n  }\r\n\r\n  var received = 0\r\n  var decoder\r\n\r\n  try {\r\n    decoder = getDecoder(encoding)\r\n  } catch (err) {\r\n    return done(err)\r\n  }\r\n\r\n  var buffer = decoder\r\n    ? ''\r\n    : []\r\n\r\n  // attach listeners\r\n  stream.on('aborted', onAborted)\r\n  stream.on('close', cleanup)\r\n  stream.on('data', onData)\r\n  stream.on('end', onEnd)\r\n  stream.on('error', onEnd)\r\n\r\n  // mark sync section complete\r\n  sync = false\r\n\r\n  function done () {\r\n    var args = new Array(arguments.length)\r\n\r\n    // copy arguments\r\n    for (var i = 0; i < args.length; i++) {\r\n      args[i] = arguments[i]\r\n    }\r\n\r\n    // mark complete\r\n    complete = true\r\n\r\n    if (sync) {\r\n      process.nextTick(invokeCallback)\r\n    } else {\r\n      invokeCallback()\r\n    }\r\n\r\n    function invokeCallback () {\r\n      cleanup()\r\n\r\n      if (args[0]) {\r\n        // halt the stream on error\r\n        halt(stream)\r\n      }\r\n\r\n      callback.apply(null, args)\r\n    }\r\n  }\r\n\r\n  function onAborted () {\r\n    if (complete) return\r\n\r\n    done(createError(400, 'request aborted', {\r\n      code: 'ECONNABORTED',\r\n      expected: length,\r\n      length: length,\r\n      received: received,\r\n      type: 'request.aborted'\r\n    }))\r\n  }\r\n\r\n  function onData (chunk) {\r\n    if (complete) return\r\n\r\n    received += chunk.length\r\n\r\n    if (limit !== null && received > limit) {\r\n      done(createError(413, 'request entity too large', {\r\n        limit: limit,\r\n        received: received,\r\n        type: 'entity.too.large'\r\n      }))\r\n    } else if (decoder) {\r\n      buffer += decoder.write(chunk)\r\n    } else {\r\n      buffer.push(chunk)\r\n    }\r\n  }\r\n\r\n  function onEnd (err) {\r\n    if (complete) return\r\n    if (err) return done(err)\r\n\r\n    if (length !== null && received !== length) {\r\n      done(createError(400, 'request size did not match content length', {\r\n        expected: length,\r\n        length: length,\r\n        received: received,\r\n        type: 'request.size.invalid'\r\n      }))\r\n    } else {\r\n      var string = decoder\r\n        ? buffer + (decoder.end() || '')\r\n        : Buffer.concat(buffer)\r\n      done(null, string)\r\n    }\r\n  }\r\n\r\n  function cleanup () {\r\n    buffer = null\r\n\r\n    stream.removeListener('aborted', onAborted)\r\n    stream.removeListener('data', onData)\r\n    stream.removeListener('end', onEnd)\r\n    stream.removeListener('error', onEnd)\r\n    stream.removeListener('close', cleanup)\r\n  }\r\n}\r\n\r\n/**\r\n * Try to require async_hooks\r\n * @private\r\n */\r\n\r\nfunction tryRequireAsyncHooks () {\r\n  try {\r\n    return require('async_hooks')\r\n  } catch (e) {\r\n    return {}\r\n  }\r\n}\r\n\r\n/**\r\n * Wrap function with async resource, if possible.\r\n * AsyncResource.bind static method backported.\r\n * @private\r\n */\r\n\r\nfunction wrap (fn) {\r\n  var res\r\n\r\n  // create anonymous resource\r\n  if (asyncHooks.AsyncResource) {\r\n    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn')\r\n  }\r\n\r\n  // incompatible node.js\r\n  if (!res || !res.runInAsyncScope) {\r\n    return fn\r\n  }\r\n\r\n  // return bound function\r\n  return res.runInAsyncScope.bind(res, fn, null)\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}